#!/usr/bin/env perl
use v5.14;

use Getopt::Long;
use Scalar::Util;
use HTTP::Tiny;

my $VERSION = '0.2.0';

binmode STDOUT, ":encoding(UTF-8)";

# get command line options

my %opt;
Getopt::Long::Configure('bundling');
GetOptions(\%opt,
    'help|h|?',
    'version|v',
    'api=s',
    'format|f=s',
    'query|q=s',
    'no-execute|n!',
    'default-prefixes!',
    'force!',
) or exit 1;

if ($opt{version}) {
    say "wdq $VERSION";
    exit;
} elsif ($opt{help}) {
    require Pod::Usage;
    my $string;
    open my $output, '>', \$string;
    Pod::Usage::pod2usage(
        -msg      => "wdq [OPTIONS] < query\n",
        -sections => [qw(USAGE OPTIONS)],
        -exitval  => 'NOEXIT',
        -output   => $output,
        indent    => 2,
    );
    $string =~ s/\n\n  --/\n  --/gm;
    print $string;
    exit;
}

# default values
$opt{api} //= 'https://query.wikidata.org/bigdata/namespace/wdq/sparql';
$opt{format} = lc($opt{format} // 'json');
$opt{'default-prefixes'} //= 1;
$opt{query} //= '-';


sub simple_node {
    if (!Scalar::Util::blessed($_[0])) {
        ''
    } elsif ($_[0]->isa('RDF::Trine::Node::Resource')) {
        $_[0]->uri_value
    } elsif ($_[0]->isa('RDF::Trine::Node::Literal')) {
        $_[0]->literal_value
    } else {
        $_[0]->sse
    }
}

my %FORMATS = (
    json => ['json'],
    xml  => ['xml'],
    tsv  => [ json => sub {
        my ($iter, $vars, $out) = @_;
        say $out join("\t", map { "?$_" } @$vars);
        while (my $r = $iter->next) {
            say $out join "\t",
                map { Scalar::Util::blessed($_) ? $_->as_ntriples : '' }
                map { $r->{ $_ } } @$vars;
        }
   }],
    csv => [ json => sub {
        my ($iter, $vars, $out) = @_;
        require Text::CSV;
        my $csv = Text::CSV->new({binary => 1});
        $csv->print($out, $vars);
        print $out "\n";
        while (my $r = $iter->next) {
            $csv->print($out, [ map { simple_node($r->{ $_ }) } @$vars ]);
            print $out "\n";
        }
    }],
    simple => [ json => sub {
        my ($iter, $vars, $out) = @_;
        require JSON;
        my $json = [];
        while (my $r = $iter->next) {
            push @$json, { map { $_ => simple_node($r->{ $_ }) } @$vars };
        }
        say $out JSON->new->pretty->encode($json);
    }],
);

my $format = $FORMATS{$opt{format}} // do {
    say STDERR "Unknown format: $opt{format}";
    exit 1;
};

my %namespaces = (
    rdf => 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    xsd => 'http://www.w3.org/2001/XMLSchema#',
    rdfs => 'http://www.w3.org/2000/01/rdf-schema#',
    owl => 'http://www.w3.org/2002/07/owl#',
    skos => 'http://www.w3.org/2004/02/skos/core#',
    schema => 'http://schema.org/',
    cc => 'http://creativecommons.org/ns#',
    geo => 'http://www.opengis.net/ont/geosparql#',
    prov => 'http://www.w3.org/ns/prov#',
    wikibase => 'http://wikiba.se/ontology#',
    wdata => 'http://www.wikidata.org/wiki/Special:EntityData/',
    wd => 'http://www.wikidata.org/entity/',
    wdt => 'http://www.wikidata.org/prop/direct/',
    wds => 'http://www.wikidata.org/entity/statement/',
    p => 'http://www.wikidata.org/prop/',
    wdref => 'http://www.wikidata.org/reference/',
    wdv => 'http://www.wikidata.org/value/',
    ps => 'http://www.wikidata.org/prop/statement/',
    psv => 'http://www.wikidata.org/prop/statement/value/',
    pq => 'http://www.wikidata.org/prop/qualifier/',
    pqv => 'http://www.wikidata.org/prop/qualifier/value/',
    pr => 'http://www.wikidata.org/prop/reference/',
    prv => 'http://www.wikidata.org/prop/reference/value/',
    wdno => 'http://www.wikidata.org/prop/novalue/',
    # blazegraph SPARQL extensions
    bd => 'http://www.bigdata.com/',
    bds => 'http://www.bigdata.com/rdf/search#',
    fts => 'http://www.bigdata.com/rdf/fts#',
);

my $query;
{
    local $/ = undef;
    if ($opt{query} eq '-') {
        $query = <STDIN>;
    } elsif ($opt{query} !~ /^\s*{/m) {
        open my $fh, '<', $opt{query}
            or die "failed to open file ".$opt{query};
        $query = <$fh>;
        open my $fh;
    } else {
        $query = $opt{query};
    }

    if ($query =~ /^\s*{/m) {
        $query = "SELECT * WHERE $query";
    }

    if ($opt{'default-prefixes'}) {
        # Add PREFIX for actually used and known prefixes
        my %ns;
        my $ps = join '|', keys %namespaces;
        $ns{$_} = $namespaces{$_} for $query =~ /($ps):/mg;
        my @prefixes = map { "PREFIX $_: <$ns{$_}>" } sort keys %ns;
        $query = join "\n", @prefixes, $query;
    }
}

my $sparql = do {
    require RDF::Query;
    my $q = RDF::Query->new($query);
    unless ($q) {
        if ($opt{'force'}) {
            warn "SPARQL query seems invalid!\n";
            undef;
        } else {
            say STDERR "Invalid SPARQL query!";
            exit 1;
        }
    }
};

my $variables;
if ($sparql) {
    $variables = [ map { $_->name } @{$sparql->parsed->{variables}} ];
    $query = $sparql->as_sparql;
    # FIXME: use correct namespace
    $query =~ s|PREFIX bd: <http://www.bigdata.com/>\n||m;
}

if ($opt{'no-execute'}) {
    chomp $query;
    say $query;
    exit;
}

my $http = HTTP::Tiny->new(
    default_headers => {
        agent => "wdq/$VERSION"
    }
);

my $param = {
    format => $format->[0],
    query  => $query,
};
# TODO: HTTP POST
my $url = $opt{api}.'?'.$http->www_form_urlencode($param);
my $res = $http->get($url);
if (!$res->{success}) {
    say STDERR $res->{content};
    exit 2;
}


if ($format->[0] eq $opt{format}) {
    say $res->{content};
} else {

    # parse result
    require RDF::Trine::Iterator::JSONHandler;
    my $iter = RDF::Trine::Iterator::JSONHandler->new->parse($res->{content});
    my $vars = $variables // sort keys %{$iter->peek};
    my $out  = \*STDOUT;
  
    # convert result
    $format->[1]->($iter, $vars, $out);
}

__END__

=head1 NAME

wdq - Command line access to Wikidata Query Service

=head1 USAGE

Access L<Wikidata Query Service|https://query.wikidata.org/> via command line.
A SPARQL query is read from STDIN or option C<query>. Default namespaces are
added automatically. If a query starts with C<{> a C<SELECT> clause is added.

=head1 EXAMPLES

  # get all parts of the solar system
  wdq -q '{ ?c wdt:P361 wd:Q544 }'

=head1 OPTIONS

=over

=item --query|-q

File with query (C<-> for STDIN as default). If query begins with C<{> it is
used as WHERE clause of a SPARQL query. PREFIX definitions are included
automatically.

=item --format

Output format (C<json> as default). Supports C<json>, C<xml>, C<tsv>, and
C<csv> SPARQL result format and C<simple> for simplified JSON.

=item --no-default-prefixes

Don't add default namespace prefixes to the SPARQL query

=item --api

SPARQL endpoint. Default value:
C<https://query.wikidata.org/bigdata/namespace/wdq/sparql>

=item --no-execute|-n

Don't execute query but show it in expanded form. Useful to validate and
pretty-print queries.

=item --help|-h|-?

Show usage help

=item --version

Show version if this script

=back

=head1 COPYRIGHT AND LICENSE

Copyright by Jakob Voss C<voss@gbv.de>

Based on a PHP script by Marius Hoch C<hoo@online.de>
at L<https://github.com/mariushoch/asparagus>.

Licensed under GPL 2.0+

=cut
