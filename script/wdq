#!/usr/bin/env perl
use v5.14;

use Getopt::Long;
use Scalar::Util qw(blessed);
use Encode qw(decode_utf8 encode_utf8);
use JSON;

our $VERSION = '0.3.6';

# Assume everything outside is UTF-8
binmode( STDIN,  ":encoding(UTF-8)" );
binmode( STDOUT, ":encoding(UTF-8)" );
binmode( STDERR, ":encoding(UTF-8)" );
@ARGV = map { decode_utf8($_) } @ARGV;

# get command line options
my %OPT;
Getopt::Long::Configure('bundling');
GetOptions(
    \%OPT,
    'help|h|?', 'version|V', 'man', 'ontology',
    'api=s',
    'format|f=s',
    'query|q=s',
    'ids|i!',
    'language|g=s',
    'color|C!',
    'header!', 'H!',
    'no-execute|n!',
    'no-mediawiki|m!',
    'N!',
    'ignore!',
    'limit=i', '1!', '2!', '3!', '4!', '5!', '6!', '7!', '8!', '9!',
    'default-prefixes!',
    'response=s',    # not documented
    'export=s',
    'force!',
) or exit 1;

# use color by default if output is terminal
$OPT{color_stderr} = $OPT{color} // -t STDERR;    ## no critic
$OPT{color} //= -t STDOUT;                        ## no critic

my %COLORS = (
    t => "\e[1;39m",                              # title : bold
    v => "\e[0;32m",                              # value: green
    n => "\e[0;34m",                              # name: blue
    i => "\e[0;33m",                              # identifier: yellow
    e => "\e[1;31m",                              # error: bold red
);

sub cDefault {
    $OPT{color} ? "\e[0;39m$_[0]\e[0m" : $_[0]    # default
}

sub cBold {
    $OPT{color} ? "$COLORS{t}$_[0]\e[0m" : $_[0];
}

sub cValue {
    $OPT{color} ? "$COLORS{v}$_[0]\e[0m" : $_[0];
}

sub cName {
    $OPT{color} ? "$COLORS{n}$_[0]\e[0m" : $_[0];
}

sub cIdentifier {
    $OPT{color} ? "$COLORS{i}$_[0]\e[0m" : $_[0];
}

sub warning {
    say STDERR $OPT{color_stderr} ? "$COLORS{e}$_[0]\e[0m" : $_[0];
}

my %NAMESPACES = (

    # standard ontologies
    rdf    => 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    xsd    => 'http://www.w3.org/2001/XMLSchema#',
    rdfs   => 'http://www.w3.org/2000/01/rdf-schema#',
    owl    => 'http://www.w3.org/2002/07/owl#',
    skos   => 'http://www.w3.org/2004/02/skos/core#',
    schema => 'http://schema.org/',
    geo    => 'http://www.opengis.net/ont/geosparql#',
    prov   => 'http://www.w3.org/ns/prov#',

    # Wikibase ontology
    wikibase => 'http://wikiba.se/ontology#',
    wd       => 'http://www.wikidata.org/entity/',
    wdt      => 'http://www.wikidata.org/prop/direct/',
    wds      => 'http://www.wikidata.org/entity/statement/',
    p        => 'http://www.wikidata.org/prop/',
    wdref    => 'http://www.wikidata.org/reference/',
    wdv      => 'http://www.wikidata.org/value/',
    ps       => 'http://www.wikidata.org/prop/statement/',
    psv      => 'http://www.wikidata.org/prop/statement/value/',
    pq       => 'http://www.wikidata.org/prop/qualifier/',
    pqv      => 'http://www.wikidata.org/prop/qualifier/value/',
    pr       => 'http://www.wikidata.org/prop/reference/',
    prv      => 'http://www.wikidata.org/prop/reference/value/',
    wdno     => 'http://www.wikidata.org/prop/novalue/',

    # blazegraph SPARQL extensions
    hint => 'http://www.bigdata.com/queryHints#',
    bd   => 'http://www.bigdata.com/rdf#',
    bds  => 'http://www.bigdata.com/rdf/search#',
    fts  => 'http://www.bigdata.com/rdf/fts#',

    # not used in Wikidata Query Service
    wdata => 'http://www.wikidata.org/wiki/Special:EntityData/',
    cc    => 'http://creativecommons.org/ns#',
);

my $LANGUAGE_PATTERN = qr{^([a-z]+(-[a-zA-Z0-9]+)*)$};

my $ENTITY_PATTERN = qr{^
    (https?://www\.wikidata\.org/
     (wiki|entity|wiki/Special:EntityData)/)?
     (?<id>(q|(Property:)?p)\d+)
$}ix;

my $WIKIDATA_ID_PATTERN = qr{^
    http://www\.wikidata\.org/
    ( entity (/statement)? | reference | value |
      prop (/(statement|qualifier|reference)/value)?)
    /(?<id>.+)
$}x;

my $SITELINK_PATTERN = qr{^
    https?://
    (?<base>
      ( [^.]+. ( wikipedia | wiktionary | wikibooks | wikiquote |
                wikisource | wikinews | wikiversity | wikivoyage )
      | ( commons | species )\.wikimedia
    )\.org)
    /wiki/
    (?<title>.+)
}x;

sub pod_text {
    require Pod::Usage;
    my $text;
    open my $out, '>', \$text;
    Pod::Usage::pod2usage(
        -exit    => 'NOEXIT',
        -output  => $out,
        -verbose => 99,
        indent   => 2,
        @_
    );
    $text =~ s/^(.[^\s].+:)$/cBold($1)/mge;    # headers
    $text;
}

# help mode
if ( $OPT{help} ) {
    @ARGV = qw(help);
}
elsif ( $OPT{version} ) {
    @ARGV = qw(help version);
}
elsif ( $OPT{namespaces} ) {
    warning("--namespaces is deprecated. Use 'wdq help namespaces' instead!");
    @ARGV = qw(help namespaces);
}
elsif ( $OPT{ontology} ) {
    warning("--ontology is deprecated. Use 'wdq help ontology' instead!");
    @ARGV = qw(help ontology);
}

if ( @ARGV and $ARGV[0] eq 'help' ) {
    shift @ARGV;
    my $topic = lc( shift @ARGV );

    if ( $topic eq 'version' ) {
        say "wdq $VERSION";
    }
    elsif ( $topic =~ /^(namespace|prefix)/ ) {
        for my $prefix ( sort keys %NAMESPACES ) {
            printf "%8s: %s\n", $prefix, $NAMESPACES{$prefix};
        }
    }
    elsif ( $topic eq 'output' ) {
        print pod_text( -sections => ['OUTPUT'] );
    }
    elsif ( $topic =~ /^(formats?)$/ ) {
        print pod_text( -sections => ['OUTPUT/Formats'] );
    }
    elsif ( $topic eq 'pretty' ) {
        my $help = pod_text( -sections => ['OUTPUT/Pretty'] );
        $help =~ s/({(.)~.+})/$COLORS{$2}.$1."\e[0m"/mge;
        print $help;
    }
    elsif ( $topic eq 'export' ) {
        print pod_text( -sections => ['OUTPUT/Export'] );
    }
    elsif ( $topic eq 'ontology' ) {
        my $help = pod_text( -sections => ['WIKIDATA ONTOLOGY'] );
        $help =~ s/^.*Wikidata Ontology:.*\n//;
        $help =~ s/^(    |  )//mg;
        $help =~ s/^([a-z]+)/cBold($1)/mgei;
        $help =~ s/ ([A-Z][A-Za-z]+)/" ".cBold($1)/mge;
        $help =~ s/(<--|-->|--)/cDefault($1)/mge;
        $help =~ s/ ([a-z]+:([a-zA-Z_]+)?|[a-z][a-zA-Z]+)/" ".cName($1)/mge;
        $help =~ s/(<[^ >]+>|@[a-z_]+)/cIdentifier($1)/mge;
        $help =~ s/("[^"\n]+")/cValue($1)/mge;
        print $help;
    }
    else {
        # TODO: use pretty string template instead
        my $help = pod_text(
            -msg => cBold("wdq ")
              . cValue("[query]  ")
              . cName("[OPTIONS]")
              . " < query\n"
              . cBold("wdq ")
              . cValue(" lookup  ")
              . cName("[OPTIONS]")
              . " < ids\n"
              . cBold("wdq ")
              . cValue("[lookup] ")
              . cName("[OPTIONS]")
              . " ids...\n"
              . cBold("wdq ")
              . cValue("help ")
              . cValue("[format|output|ontology|prefixes|pretty|export]")
              . "\n",
            -sections => [qw(USAGE OPTIONS)],
        );
        $help =~ s/\n\n  -/\n  -/gm;
        $help =~ s/^      /    /mg;
        if ( $OPT{color} ) {
            $help =~ s/^([a-z]+:)/cBold($1)/mgei;          # headers
            $help =~ s/^(  --?.*)$/cName($1)/mge;          # options
            $help =~ s/("[^"\n]+")/cValue($1)/mge;         # strings
            $help =~ s/(<[^>\n]+>)/cIdentifier($1)/mge;    # URLs
        }
        chomp $help;
        print $help;
    }
    exit;
}

if ( $OPT{man} ) {
    my $module = $OPT{color} ? 'Pod::Text::Color' : 'Pod::Text';

    # may fail if pure script installed by hand
    eval "require $module; require App::wdq";              ## no critic
    $module->new->parse_from_file( $INC{'App/wdq.pm'} // $0 );
    exit;
}

# default SPARQL endpoint
$OPT{api} //= 'https://query.wikidata.org/bigdata/namespace/wdq/sparql';

# default output format
$OPT{format} = lc( $OPT{format} // 'simple' );

# add default prefixes by default
$OPT{'default-prefixes'} //= 1;

# include header in output
$OPT{header} //= $OPT{H} ? 0 : 1;

# limit given as single digit option
foreach ( grep { $OPT{$_} } 1 .. 9 ) {
    $OPT{limit} = $_ if !$OPT{limit} or $OPT{limit} > $_;
}

# validate language and set default value if missing
$OPT{language} //= do { my $l = $ENV{LANG} // 'en'; $l =~ s/_.*//; $l };
$OPT{language} = lc( $OPT{language} );
if ( grep { $_ !~ $LANGUAGE_PATTERN } split ",", $OPT{language} ) {
    warning("invalid language(s): $OPT{language}");
    exit 1;
}

# disable all requests
if ( $OPT{N} ) {
    $OPT{'no-mediawiki'} = 1;
    $OPT{'no-execute'}   = 1;
}

my $MODE = !@ARGV ? 'query' : do {
    my $arg = $ARGV[0];
    $arg =~ s/^\s*|\s*$//g;
    if ( $arg =~ /^(query|lookup|search)$/ ) {
        shift @ARGV;
    }
    elsif ( $arg =~ $ENTITY_PATTERN or $arg =~ $SITELINK_PATTERN ) {
        'lookup';
    }
    else {
        my $guess = () = $arg =~ /[a-z]+:[^\s]/gi;
        $guess += () = $arg =~ /<[^>]+>/g;
        $guess += () = $arg =~ /[?\$][^\s]/g;
        if ( $guess > 2 ) {
            warning("ignoring additional command line argument")
              if $OPT{query} or @ARGV > 1;
            'query';
        }
        else {
            'search';
        }
    }
};

# require only if actually needed
require RDF::Query;

# monkey-patch RDF::Query to keep minimum required version at Ubuntu 14.04 LTS
require version;
if ( version->parse($RDF::Query::VERSION) < version->parse('2.915_01') ) {
    require RDF::Query::Parser::SPARQL;
    *RDF::Query::Node::Resource::as_sparql = sub {
        my $self    = shift;
        my $context = shift || {};
        my $uri     = $self->uri_value;
        my $ns      = $context->{namespaces} || {};
        my %ns      = %$ns;
        foreach my $k ( keys %ns ) {
            no warnings 'uninitialized';
            if ( $k eq '__DEFAULT__' ) {
                $k = '';
            }
            my $v = $ns{$k};
            if ( index( $uri, $v ) == 0 ) {
                my $local = substr( $uri, length($v) );
                if ( $local =~ $RDF::Query::Parser::SPARQL::r_PN_LOCAL ) {
                    my $qname = join( ':', $k, $local );
                    return $qname;
                }
            }
        }
        '<' . URI->new( encode_utf8( $self->uri_value ) )->canonical . '>';
      }
}

my $EXPORTER;
if ( $OPT{export} || $OPT{format} eq 'export' ) {
    $EXPORTER = eval {
        require Catmandu;
        Catmandu->exporter( $OPT{export} // 'JSON', header => $OPT{header} );
    };
    if ($@) {
        warning("option export requires Perl module "
              . "Catmandu::Exporter::$OPT{export}" );
        exit 1;
    }
    elsif ( $OPT{format} !~ /^(ldjson|simple)$/ ) {
        warning("option export overrides option format");
        Catmandu->load();
    }
    $OPT{format} = 'export';
}

# output formats
package App::wdq::Output {

    sub add {
        my ( $self, $row ) = @_;
        $self->{format}{row}->( $self, $row );
    }

    sub end {
        my ($self) = @_;
        return unless $self->{format}{post};
        $self->{format}{post}->($self);
    }

    sub print {
        my $self = shift;
        print { $self->{out} } @_;
    }

    sub say {
        my $self = shift;
        say { $self->{out} } @_;
    }
}

package App::wdq::Format {

    sub new {
        my $class = shift;
        bless {@_}, $class;
    }

    sub emit {
        my ( $self, $rows, $vars, $out ) = @_;
        my $output = $self->start( $vars, $out );
        $output->add($_) for @$rows;
        $output->end();
    }

    sub start {
        my ( $self, $vars, $out ) = @_;
        my $output = bless { format => $self, vars => $vars, out => $out },
          'App::wdq::Output';
        $self->{pre}->($output) if $self->{pre};
        return $output;
    }
}

sub simple_node {
    if ( !blessed( $_[0] ) ) {
        '';
    }
    elsif ( $_[0]->isa('RDF::Trine::Node::Resource') ) {
        $_[0]->uri_value;
    }
    elsif ( $_[0]->isa('RDF::Trine::Node::Literal') ) {
        $_[0]->literal_value;
    }
    else {
        $_[0]->sse;
    }
}

sub simple_row {
    my ( $row, $vars ) = @_;
    return {
        map { $_ => simple_node( $row->{$_} ) }
        grep { defined $row->{$_} } @$vars
    };
}

sub json {
    ( state $JSON= JSON->new->canonical->allow_nonref )->encode( $_[0] );
}

sub pretty_json {
    ( state $JSON= JSON->new->pretty->canonical )->encode( $_[0] );
}

sub xml {
    my $text = shift;
    $text =~ s/&/&amp;/gm;
    $text =~ s/</&lt;/gm;
    $text =~ s/>/&gt;/gm;
    $text;
}

sub xmlattr {
    my $text = xml(shift);
    $text =~ s/"/&quot;/gm;
    $text;
}

my %FORMATS = (

    # SPARQL Query Results JSON
    json => App::wdq::Format->new(
        pre => sub {
            my $o = shift;
            $o->print(
                "{\n  \"head\": {\n    \"vars\": [",
                join( ", ", map { cName( json($_) ) } @{ $o->{vars} } ),
                "]\n  },\n  \"results\": {\n    \"bindings\": ["
            );
        },
        row => sub {
            my ( $o, $row ) = @_;
            $o->print( $o->{count}++ ? ", {\n" : " {\n" );
            my $delim = 0;
            foreach my $v ( @{ $o->{vars} } ) {
                next unless defined $row->{$v};
                $o->say(",") if $delim++;
                $o->print( "      " . cName( json($v) ) . ": " );
                my $node = $row->{$v}->as_hashref;
                $node->{'xml:lang'} = delete $node->{lang} if $node->{lang};
                my $json = pretty_json($node);
                $json =~ s/^ /      /mg;
                $json =~ s/}\n$/      }/;
                $json =~
                  s/^(\s+"[a-z:]+")\s*:(.*")(,)?$/"$1:".cValue($2).$3/mge;
                $o->print($json);
            }
            $o->print("\n    }");
        },
        post => sub {
            $_[0]->print(" ]\n  }\n}\n");
        }
    ),

    # SPARQL Query Results XML
    xml => App::wdq::Format->new(
        pre => sub {
            my $o = shift;
            $o->say('<?xml version="1.0"?>');
            $o->say('<sparql xmlns="http://www.w3.org/2005/sparql-results#">');
            $o->say('  <head>');
            foreach ( @{ $o->{vars} } ) {
                my $name = cName( xmlattr($_) );
                $o->say("    <variable name=\"$name\"/>");
            }
            $o->say('  </head>');
            $o->say('  <results>');
        },
        row => sub {
            my ( $o, $row ) = @_;
            $o->say('    <result>');
            foreach ( @{ $o->{vars} } ) {
                my $node = $row->{$_} // next;
                my $name = cName( xmlattr($_) );
                $o->say("      <binding name=\"$name\">");
                if ( $node->is_blank ) {
                    $o->say(
                        "        <bnode>" . xml( $node->value ) . '</node>' );
                }
                elsif ( $node->is_resource ) {
                    $o->say("        <uri>"
                          . cIdentifier( xml( $node->uri_value ) )
                          . '</uri>' );
                }
                else {
                    my $literal = "        <literal";
                    if ( $node->literal_value_language ) {
                        $literal .=
                          ' xml:lang="'
                          . cIdentifier(
                            xmlattr( $node->literal_value_language ) )
                          . '"';
                    }
                    elsif ( $node->literal_datatype ) {
                        $literal .=
                            ' datatype="'
                          . cIdentifier( xmlattr( $node->literal_datatype ) )
                          . '"';
                    }
                    $o->say("$literal>"
                          . cValue( xml( $node->literal_value ) )
                          . "</literal>" );
                }
                $o->say('      </binding>');
            }
            $o->say('    </result>');
        },
        post => sub {
            $_[0]->say('  </results>');
            $_[0]->say('</sparql>');
        }
    ),

    # SPARQL TSV
    tsv => App::wdq::Format->new(
        pre => sub {
            my $o = shift;
            $o->say( join( "\t", map { "?$_" } @{ $o->{vars} } ) );
        },
        row => sub {
            my ( $o, $row ) = @_;
            $o->say(
                join "\t",
                map { blessed($_) ? $_->as_ntriples : '' }
                  map { $row->{$_} } @{ $o->{vars} }
            );
        }
    ),

    # SPARQL CSV
    csv => App::wdq::Format->new(
        pre => sub {
            my $o = shift;
            $o->say( join cDefault(','), map { cName($_) } @{ $o->{vars} } )
              if $OPT{header};
        },
        row => sub {
            my ( $o, $row ) = @_;
            $o->say(
                join cDefault(','),
                map {
                    my $s = simple_node( $row->{$_} );
                    if ( $s =~ /[",\x0A\x0D]/ ) {
                        $s =~ s/"/""/g;
                        $s = "\"$s\"";
                    }
                    cValue($s)
                } @{ $o->{vars} }
            );
        }
    ),

    # simple JSON key-value structure
    simple => App::wdq::Format->new(
        pre => sub {
            my $o = shift;
            $o->{count} = 0;
            $o->print("[ ");
        },
        row => sub {
            my ( $o, $row ) = @_;
            my $json = pretty_json( simple_row( $row, $o->{vars} ) );
            chomp $json;
            $json =~ s/^\s+("[^"]+") : (".*")(,)?$/
                      '  '.cName($1).': '.cValue($2).$3/mge;
            $o->print(",") if $o->{count}++;
            $o->print($json);
        },
        post => sub {
            my $o = shift;
            if ( $o->{count} ) {
                $o->say(" ]");
            }
            elsif ( defined $o->{count} ) {
                $o->say("]");
            }
            else {    # FIXME: this should not be called
                $o->say("[]");
            }
        }
    ),

    # simple line-delimited JSON key-value structure
    ldjson => App::wdq::Format->new(
        row => sub {
            my ( $o, $row ) = @_;
            $o->say( json( simple_row( $row, $o->{vars} ) ) );
        }
    ),

    # pipe to Catmandu exporter
    export => App::wdq::Format->new(
        pre => sub {
            $_[0]->{exporter} = $EXPORTER;
        },
        row => sub {
            my ( $o, $row ) = @_;
            $o->{exporter}->add( simple_row( $row, $o->{vars} ) );
        },
        post => sub {
            $_[0]->{exporter}->commit;
        }
    ),

    pretty => App::wdq::Format->new(
        row => sub {
            my ( $o, $row ) = @_;
            my $record = $OPT{pretty};

            $record =~ s!{([tvnie]~)?(([<>]?)(\d+))?([^}]+)}!
                my $s = simple_node($row->{$5});
                if ( $4 ) {
                    $s = substr($s, 0, $4-1) . "\x{2026}" if length $s > $4;
                    $s = sprintf($3 eq '<' ? "%-$4s" : "%$4s", $s) if $3;
                }
                $s = $COLORS{substr $1,0,1} . $s . "\e[0m" if $1 and $OPT{color};
                $s;
            !eg;
            $o->say($record);
        }
    ),
);

if ( $OPT{format} =~ /{[^}]+}/ ) {
    $OPT{pretty} = $OPT{format};
    $OPT{format} = 'pretty';
}
elsif ( $OPT{format} eq 'pretty' ) {
    $OPT{pretty} //= '{v~label} ({i~id}): {v~description}';
    $OPT{ids}    //= 1;
}

my $format = $FORMATS{ $OPT{format} } // do {
    warning("unknown format: $OPT{format}");
    exit 1;
};

sub expand_query {
    my $query = shift;

    if ( $query =~ /^\s*{/m ) {
        $query = "SELECT * WHERE $query";
    }
    elsif ( $query !~ /^[^{]*SELECT/ ) {
        $query = "SELECT * WHERE { $query }";
    }

    if ( $OPT{'default-prefixes'} ) {

        # Add PREFIX for actually used and known prefixes
        my %ns;
        my $ps = join '|', keys %NAMESPACES;
        $ns{$_} = $NAMESPACES{$_} for $query =~ /($ps):[^\/]/mg;
        my @prefixes = map { "PREFIX $_: <$ns{$_}>" } sort keys %ns;
        $query = join "\n", @prefixes, $query;
    }

    $query;
}

sub http_get {
    require HTTP::Tiny;
    state $http =
      HTTP::Tiny->new( default_headers => { agent => "wdq/$VERSION" } );

    if ( $OPT{response} ) {
        local ( @ARGV, $/ ) = $OPT{response};
        return <>;
    }

    my ( $url, %query ) = @_;
    $query{format} = 'json';

    $url .= '?' . $http->www_form_urlencode( \%query );
    my $res = $http->get($url);

    if ( !$res->{success} ) {
        if ( $OPT{ignore} ) {
            return;
        }
        else {
            warning("HTTP request failed");
            say STDERR $res->{content};
            exit 1;
        }
    }

    $res->{content};
}

sub get_qid_from_sitelink {
    my $api   = "https://$_[0]/w/api.php";
    my $title = $_[1];

    my $res = http_get(
        $api,
        action    => 'query',
        prop      => 'pageprops',
        titles    => $title,
        redirects => 1
    );

    my $data = JSON->new->decode($res);
    my ($page) = values %{ $data->{query}->{pages} };
    return unless $page->{pageprops};
    return $page->{pageprops}->{wikibase_item};
}

sub get_lookup_query {
    my $id = shift;

    my $entity_id;

    if ( $id =~ $ENTITY_PATTERN ) {
        $entity_id = $+{id};
        $entity_id =~ s/Property://i;
    }
    else {
        # URL could be percent-encoded or not, so normalize
        my $uri = URI->new($id);
        if ( $uri and $uri->canonical =~ $SITELINK_PATTERN ) {
            my ( $base, $title ) = ( $+{base}, $+{title} );

            # unescape to UTF-8 octets
            $title =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
            $title = decode_utf8($title);

            if ( $OPT{'no-mediawiki'} ) {
                warning("MediaWiki API disabled");
                exit 1;
            }
            $entity_id = get_qid_from_sitelink( $base, $title );
            unless ($entity_id) {
                warning("Wikidata item not found: $id");
                return;
            }
        }
    }

    unless ($entity_id) {
        warning("unknown identifier: $id");
        return;
    }

    my $uri = "http://www.wikidata.org/entity/" . uc($entity_id);

    return <<SPARQL;
SELECT ?id ?idLabel ?idDescription WHERE {
    BIND(<$uri> AS ?id)
    SERVICE wikibase:label {
        bd:serviceParam wikibase:language "$OPT{language}" .
    }
}
SPARQL
}

sub map_ids {
    my $row = shift;
    foreach my $name ( keys %$row ) {
        my $v = $row->{$name};
        next unless $v->isa('RDF::Trine::Node::Resource');
        my $id;
        $id = $+{id} if $v->uri_value =~ $ENTITY_PATTERN;
        $id = $+{id} if $v->uri_value =~ $WIKIDATA_ID_PATTERN;
        $row->{$name} = RDF::Trine::Node::Literal->new($id) if $id;
    }
    $row;
}

sub parse_response {
    my ( $json, @map ) = @_;

    require RDF::Trine::Iterator::JSONHandler;
    return RDF::Trine::Iterator->new( [], 'bindings', [] ) unless $json;

    my $iter = RDF::Trine::Iterator::JSONHandler->new->parse($json);

    unshift @map, \&map_ids if $OPT{ids};
    $iter = RDF::Trine::Iterator::smap( $_, $iter ) for @map;

    $iter;
}

if ( $MODE eq 'lookup' ) {
    require URI;
    my $query;
    my $varmap = sub {
        $_->{label}       = delete $_->{idLabel};
        $_->{description} = delete $_->{idDescription};
        $_;
    };

    my $output;

    my $lookup = sub {
        my $id = shift;
        $id =~ s/^\s+|\s+$//g;    # trim whitespace
        return if $id eq '';      # skip empty lines

        $query = get_lookup_query($id) or return;
        $query = RDF::Query->new( expand_query($query) )->as_sparql;
        if ( $OPT{'no-execute'} ) {
            say $query;
            return;
        }

        my $res = http_get( $OPT{api}, query => $query );
        my $iterator = parse_response($res);

        $iterator = RDF::Trine::Iterator::smap( $varmap,   $iterator );
        $iterator = RDF::Trine::Iterator::smap( \&map_ids, $iterator )
          if $OPT{ids};

        $output //= $format->start( [qw(id label description)], \*STDOUT );

        while ( my $row = $iterator->next ) {
            $output->add($row);
        }
    };

    my $limit = $OPT{limit} // 0;
    if (@ARGV) {
        foreach (@ARGV) {
            $lookup->($_);
            last if !--$limit;
        }
    }
    else {
        while (<>) {
            $lookup->($_);
            last if !--$limit;
        }
    }

    $output->end() if $output;

    exit;
}

sub perform_search {
    my $query = shift;

    if ( $OPT{'no-mediawiki'} ) {
        warning("MediaWiki API disabled");
        exit 1;
    }

    my $api = "https://www.wikidata.org/w/api.php";
    my $res = http_get(
        $api,
        action   => 'wbsearchentities',
        language => $OPT{language},
        uselang  => $OPT{language},       # TODO: what if multiple?
        type     => 'item',
        search   => $query,
    );
    my $data = JSON->new->decode($res);

    $data = [
        map {
            my $label =
                $_->{match}{type} eq 'alias'
              ? $_->{label} . " (" . $_->{match}{text} . ")"
              : $_->{label};

            # TODO: include language?
            my $row = {
                id    => RDF::Trine::Node::Resource->new( $_->{concepturi} ),
                label => RDF::Trine::Node::Literal->new($label),
            };
            $row->{description} =
              RDF::Trine::Node::Literal->new( $_->{description} )
              if defined $_->{description};
            $row;
        } @{ $data->{search} }
    ];

    return $data;
}

my ( $variables, $iterator, $query );

if ( $MODE eq 'search' ) {
    $query = join ' ', @ARGV;

    # TODO: respect $OPT{limit}, $OPT{'no-execute'}, $OPT{response}
    my $data = perform_search($query);

    require RDF::Trine::Iterator::Bindings;
    $variables = [qw(id label description)];
    $iterator = RDF::Trine::Iterator::Bindings->new( $data, $variables );
}

# query mode
if ( $MODE eq 'query' ) {
    $OPT{query} //= shift @ARGV if @ARGV;
    $OPT{query} //= '-';

    my ( $query, $sparql );

    local $/ = undef;
    if ( $OPT{query} eq '-' ) {
        $query = <STDIN>;
    }
    elsif ( -f $OPT{query} or $OPT{query} !~ /[$\?\{]/ ) {
        open my $fh, '<', $OPT{query}
          or die "failed to open file " . $OPT{query};
        $query = <$fh>;
        open my $fh;
    }
    else {
        $query = $OPT{query};
    }

    $query  = expand_query($query);
    $sparql = do {
        my $q = RDF::Query->new($query);
        unless ($q) {
            if ( $OPT{'force'} ) {
                warning("SPARQL query seems invalid");
                undef;
            }
            else {
                warning("invalid SPARQL query");
                exit 1;
            }
        }
    };

    if ($sparql) {
        $variables = [ map { $_->name } @{ $sparql->parsed->{variables} } ];
        $query = $sparql->as_sparql;
        $query =~ s/\n$//mg;
        $query =~ s/\t/    /mg;
    }

    # LIMIT and OFFSET are always last so we can safely use regexp here
    if ( $OPT{limit} ) {
        $query =~ s/\n*LIMIT\s+\d+(\s+OFFSET\s+\d+)?\s*$/$1/sm;
        $query .= "\nLIMIT $OPT{limit}";
    }

    if ( $OPT{'no-execute'} ) {
        say $query;
        exit;
    }

    my $res = http_get( $OPT{api}, query => $query );
    $iterator = parse_response($res);
}

$iterator = RDF::Trine::Iterator::smap( \&map_ids, $iterator ) if $OPT{ids};

# print result
if ( $OPT{ignore} || $iterator->peek ) {
    my $vars = $variables // sort keys %{ $iterator->peek };

    # TODO: streaming
    $format->emit( [ $iterator->get_all ], $vars, \*STDOUT );
}
else {
    warning( $query ? "not found: $query" : "not found" );
    exit 1;
}

__END__

=head1 NAME

wdq - command line access to Wikidata Query Service

=head1 USAGE

Access L<Wikidata Query Service|https://query.wikidata.org/> via command line.
In C<query> mode (default), a SPARQL query is read from STDIN or option
C<--query>.  Default namespaces are and C<SELECT> clause are added if missing.
In C<lookup> mode, Wikidata entity ids, URLs, or Wikimedia project URLs are
read from STDIN or as command line arguments to look up label and description.

=head1 EXAMPLES

  # get all parts of the solar system
  wdq -q '?c wdt:P361 wd:Q544'
  wdq -q '{ ?c wdt:P361 wd:Q544 }'                # equivalent
  wdq -q 'SELECT * WHERE { ?c wdt:P361 wd:Q544 }' # equivalent

  # look up label and description
  wdq Q1
  wdq lookup Q1             # equivalent
  echo Q1 | wdq lookup      # equivalent

=head1 OPTIONS

=over

=item --query|-q QUERY

Query or query file (C<-> for STDIN as default)

=item --format|-f FORMAT|TEMPLATE

Output format or string template. Call C<wdq help formats> for details.

=item --export EXPORTER

Use a L<Catmandu> exporter as output format.

=item --no-header|-H

Exclude header in CSV output or other exporter.

=item --limit INTEGER

Add or override a LIMIT clause to limitate the number of results. Single-digit
options such as C<-1> can also be used to also set a limit.

=item --ids|-i

Abbreviate Wikidata identifier URIs as strings.

=item --language|-g

Language to query labels and descriptions in. Set to the locale by default.
This option is currentl only used on lookup mode.

=item --ignore

Ignore empty results instead of issuing warning and exit code.

=item --color|-C

By default output is colored if writing to a terminal. Disable this with
C<--no-color> or force color with C<--color> or C<-C>.

=item --api URL

SPARQL endpoint. Default value:
C<https://query.wikidata.org/bigdata/namespace/wdq/sparql>

=item --no-mediawiki|-m

Don't query MediaWiki API to map URLs to Wikidata items.

=item --no-execute|-n

Don't execute SPARQL queries but show them in expanded form. Useful to
validate and pretty-print queries. MediaWiki API requests may be 

=item -N

Don't execute any queries. Same as C<--no-mediawiki --no-execute>.

=item --help|-h|-?

Show usage help

=item --ontology

Show information about the Wikidata Ontology

=item --no-default-prefixes

Don't add default namespace prefixes to the SPARQL query

=item --man

Show detailled manual

=item --version|-V

Show version if this script

=back

=head1 OUTPUT

Output can be controlled with options C<--format>, C<--export>,
C<--header/--no-header>, and C<--color/--no-color>.

=head2 Formats

Option C<--format>/C<-f> sets an output format or string template:

=over

=item C<simple> (default)

Flat JSON without language tags (default)

=item C<ldjson>

Line delimited Flat JSON

=item C<csv>

SPARQL Query Results CSV Format. Suppress header with option
C<--no-header>/C<-H>.  Use Catmandu CSV exporter for more options

=item C<tsv>

SPARQL Query Results TSV Format

=item C<xml> 

SPARQL Query Results XML Format

=item C<json>

SPARQL Query Results JSON Format

=item C<pretty>

Default string template to print C<label>, C<id>, and C<description>.  Also
sets option C<--ids> unless disabled

=item C<...>

String template.  Call C<wdq help pretty> for details

=back

=head2 Pretty

Option C<--format> can be set to a string template with bracket expressions
(for instance C<{id}> is replaced by the value of variable C<id>). The variable
name can be preceded by a color code and a length:

  {n~foo} : highlight value of foo like a name
  {v~foo} : highlight value of foo like a value
  {i~foo} : highlight value of foo like an identifier
  {t~foo} : highlight value of foo like a title
  {e~foo} : highlight value of foo like an error

  {4foo}  : cut value of foo to 4 characters or less
  {>4foo} : cut/fill value of foo to 4 characters, right-aligned
  {<4foo} : cut/fill value of foo to 4 characters, left-aligned

  {v~<8foo} : set both, color and length

=head2 Export

Option C<--export> sets a L<Catmandu> exporter to create output with.  Given
the corresponding exporter modules installed, one can write results as C<YAML>,
Excel (C<XLS>), and Markdown table (C<Table>) among other formats:

  wdq --export YAML                               # short form
  wdq --format ldjson | catmandu convert to YAML  # equivalent

Use Catmandu config file (C<catmandu.yml>) to further configure export.  See
also tools such as L<jq|http://stedolan.github.io/jq/> and
L<miller|http://johnkerl.org/miller/> for processing results.

=head1 WIKIDATA ONTOLOGY

  Entity (item/property)
   wd:Q_ <-- owl:sameAs --> wd:Q_
         --> rdfs:label, skos:altLabel, schema:description "_"@_
         --> schema:dateModified, schema:version
         --> wdt:P_ "_", URI, _:blank
         --> p:P_ Statement

  Item
   wd:Q_ <-- schema:about <http://_.wikipedia.org/wiki/_>
                          --> schema:inLanguage, wikibase:badge

  Property
   wd:P_ --> wikibase:propertyType PropertyType
         --> wkibase:directClaim        wdt:P_
         --> wikibase:claim             p:P_
         --> wikibase:statementProperty ps:P_
         --> wikibase:statementValue    psv:P_
         --> wikibase:qualifier         pq:P_
         --> wikibase:qualifierValue    pqv:P_
         --> wikibase:reference         pr:P_
         --> wikibase:referenceValue    prv:P_
         --> wikibase:novalue           wdno:P_

  PropertyType
   wikibase: String, Url, WikibaseItem, WikibaseProperty, CommonsMedia,
             Monolingualtext, GlobeCoordinate, Quantity, Time


  Statement
   wds:_ --> wikibase:rank Rank
         --> a wdno:P_
         --> ps:P_ "_", URI, _:blank
         --> psv:P_ Value
         --> pq:P_ "_", URI, _:blank
         --> pqv:P_ Value
         --> prov:wasDerivedFrom Reference

  Reference
   wdref:_ --> pr:P_ "_", URI
           --> prv:P_ Value

  Rank
   wikibase: NormalRank, PreferredRank, DeprecatedRank, BestRank

  Value (GlobecoordinateValue/QuantityValue/TimeValue)
   wdv:_ --> wikibase: geoLatitude, geoLongitude, geoPrecision, geoGlobe URI
         --> wikibase: timeValue, timePrecision, timeTimezone, timeCalendarModel
         --> wikibase: quantityAmount, quantityUpperBound, quantityLowerBound,
                       quantityUnit URI

=head1 COPYRIGHT AND LICENSE

Copyright by Jakob Voss C<voss@gbv.de>

Based on a PHP script by Marius Hoch C<hoo@online.de>
at L<https://github.com/mariushoch/asparagus>.

Licensed under GPL 2.0+

=cut
